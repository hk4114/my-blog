# 【深度指南】如何编写高质量的 CLAUDE.md

**作者**：Kyle
**日期**：2025 年 11 月 25 日

_注：本文内容同样适用于 `AGENTS.md`，即 OpenCode、Zed、Cursor 和 Codex 等 AI 辅助工具所使用的 `CLAUDE.md` 的开源版本。_

## 核心原则：LLM 本质上是（主要）无状态的

大语言模型（LLM）本质上是无状态的函数。当模型被用于推理时，其权重参数已经固定，因此它并不具备随时间推移进行“学习”的能力。模型对你代码库的唯一认知，完全取决于你输入给它的那些 Token。

同理，像 Claude Code 这样的代码代理工具（Agent Harness），通常需要你显式地管理 Agent 的记忆。而 `CLAUDE.md`（或 `AGENTS.md`）是唯一一个默认会被包含进你与 Agent **每一次**对话中的文件。

这意味着三个重要结论：

1. 在每次会话开始时，编程 Agent 对你的代码库**一无所知**。
2. 每次启动会话，你都必须把关于代码库的重要信息告诉 Agent。
3. `CLAUDE.md` 正是完成这一任务的最佳方式。

## 用 CLAUDE.md 引导 Claude 快速上手

既然 Claude 在每次会话初始状态下对项目一无所知，你就需要利用 `CLAUDE.md` 来引导它熟悉环境。从宏观角度看，这个文件应该涵盖以下内容：

- **WHAT（是什么）**：向 Claude 介绍技术栈、项目结构。给它一张代码库的“地图”。这在单体仓库（Monorepos）中尤为重要！告诉它哪些是应用程序，哪些是共享包，以及各个组件的用途，这样它才知道去哪里寻找文件。
- **WHY（为什么）**：告诉 Claude 项目的目标以及仓库中各部分的作用。不同模块的设计意图和功能分别是什么？
- **HOW（怎么做）**：告诉 Claude 在这个项目中应该如何工作。例如，你是用 `bun` 而不是 `node` 吗？你需要包含它在项目中开展有效工作所需的所有必要信息。Claude 该如何验证它修改的代码？如何运行测试、类型检查以及编译流程？

但是，编写方式至关重要！**千万不要**试图把 Claude 可能用到的每一个命令都塞进 `CLAUDE.md` 文件里——这反而会导致效果变差。

## 现实情况：Claude 经常无视 CLAUDE.md

无论你使用哪种模型，你可能会发现 Claude 经常对 `CLAUDE.md` 里的内容视而不见。

你可以通过在 `claude code` 命令行工具和 Anthropic API 之间设置一个日志代理，并配置 `ANTHROPIC_BASE_URL` 来亲自验证这一点。Claude Code 会在发送给 Agent 的用户消息中，注入一段包含你 `CLAUDE.md` 内容的系统提示词：

```
<system-reminder>
IMPORTANT: this context may or may not be relevant to your tasks. You should not respond to this context unless it is highly relevant to your task.
</system-reminder>
```

（译注：大意为“重要提示：此上下文可能与你的任务相关，也可能无关。除非它与当前任务高度相关，否则不应响应该上下文。”）

结果就是，如果 Claude 判定 `CLAUDE.md` 的内容与当前任务无关，它就会直接忽略它。如果文件中包含大量对当前具体任务不具备**普遍适用性**的信息，Claude 忽略你指令的概率就越高。

Anthropic 为什么要这么做？确切原因不得而知，但我们可以推测：大多数 `CLAUDE.md` 文件里都塞满了一堆并不通用的指令。许多用户把这个文件当成了“热修复”补丁，针对他们不喜欢的模型行为添加了大量琐碎的指令。

我们可以推测，Claude Code 团队发现，通过让 Claude 忽略那些糟糕的指令，工具的实际表现反而更好。

## 打造高质量 CLAUDE.md 的实战指南

下文将根据“上下文工程”（Context Engineering）的最佳实践，提供编写高质量 `CLAUDE.md` 的建议。

具体情况具体分析。并非所有规则都适用于每一种环境。像往常一样，只要满足以下条件，你完全可以打破规则：

- 你清楚何时以及为什么要打破它们；
- 你有充分的理由这样做。

### 1. 少（指令）即是多

我们很容易产生一种冲动，想把 `claude` 可能运行的所有命令、所有的代码规范和风格指南都塞进 `CLAUDE.md` 里。但我们强烈建议**不要**这么做。

虽然这方面还没经过极其严谨的科学调查，但已有的研究表明：

- **指令容量有限**：前沿的推理型 LLM 大约能稳定遵循 150-200 条指令。
- **模型规模影响**：较小的模型比较大的模型能处理的指令更少；非推理型模型比推理型模型能处理的指令更少。
- **性能衰减**：小模型的表现恶化得更快、更严重。具体来说，随着指令数量增加，小模型的指令遵循能力呈**指数级衰减**，而较大的前沿推理模型则呈**线性衰减**。因此，我们建议不要使用小模型来处理多步骤任务或复杂的实施计划。
- **位置偏好**：LLM 倾向于关注提示词（Prompt）**边缘**位置的指令：即最开头（Claude Code 系统消息和 `CLAUDE.md`）和最末尾（最新的用户消息）。
- **整体降级**：随着指令总数增加，指令遵循的质量会**均匀下降**。这意味着如果你给 LLM 太多指令，它不会只忽略后面（文件底部）的指令，而是开始对所有指令都“听而不闻”。

**关于指令遵循**
我们对 Claude Code 工具的分析显示，其内置的系统提示词（System Prompt）已经包含了约 50 条独立指令。取决于你使用的模型，这可能已经占用了 Agent 可靠遵循指令容量的三分之一——这还没算上规则、插件、技能或用户消息。

这意味着你的 `CLAUDE.md` 应该包含尽可能少的指令——理想情况下，只保留那些对你的任务**普遍适用**的指令。

### 2. CLAUDE.md 的长度与适用性

在其他条件相同的情况下，如果 LLM 的上下文窗口（Context Window）里充满了聚焦的、相关的上下文（包括示例、相关文件、工具调用结果），其表现会远好于充斥着大量无关信息的情况。

由于 `CLAUDE.md` 会被带入**每一次**会话，你应该确保其内容尽可能具有**普遍适用性**。

比如，避免包含关于“如何构建新数据库 Schema”的指令——当你正在处理其他无关任务时，这些信息毫无意义，只会分散模型的注意力！

在长度方面，“少即是多”原则同样适用。虽然 Anthropic 官方没有规定 `CLAUDE.md` 应该多长，但业界的共识是 **300 行以内**为佳，越短越好。

在 HumanLayer，我们根目录下的 `CLAUDE.md` 文件甚至不到 60 行。

### 3. 渐进式披露（Progressive Disclosure）

在大型项目中，想要写一个既简洁又涵盖所有必要信息的 `CLAUDE.md` 极具挑战性。

为了解决这个问题，我们可以利用**渐进式披露**原则，确保 `claude` 只有在需要时才看到特定任务或项目的指令。

建议将特定任务的指令（如构建项目、运行测试、代码规范等）保存在单独的 Markdown 文件中，并放在项目里一个具有自解释名称的目录下，而不是全部塞进主文件里。

例如：

```
agent_docs/
|- building_the_project.md      (项目构建指南)
|- running_tests.md             (测试运行指南)
|- code_conventions.md          (代码规范)
|- service_architecture.md      (服务架构)
|- database_schema.md           (数据库结构)
|- service_communication_patterns.md (服务通信模式)

```

然后，在你的 `CLAUDE.md` 文件中，列出这些文件并附带简要描述，指示 Claude 自行判断哪些文件是相关的，并在开始工作前阅读它们。或者，让 Claude 先向你汇报它想读哪些文件，经你批准后再读。

**使用指针而非副本**。尽可能不要在这些文档中直接包含代码片段，因为它们很快就会过时。相反，使用 `file:line`（文件路径:行号）的引用方式，把 Claude 指向代码库中的权威上下文。

从概念上讲，这与 Claude Skills（技能）的工作原理非常相似，不过技能更侧重于工具的使用，而非指令遵循。

### 4. Claude 不是昂贵的 Linter

我们在 `CLAUDE.md` 中看到最常见的内容之一就是代码风格指南。**永远不要派 LLM 去做代码检查工具（Linter）的工作。** 与传统的 Linter 和格式化工具相比，LLM 成本高昂且速度极慢。我们认为你应该尽可能使用确定性的工具。

代码风格指南不可避免地会向上下文窗口中添加大量指令和大多无关的代码片段，这会降低 LLM 的性能和指令遵循能力，并吞噬宝贵的上下文空间。

LLM 具有**上下文学习（In-context Learning）**能力！如果你的代码已经遵循了一套特定的风格或模式，你会发现，只需让 Agent 在代码库中搜索几次（或阅读一份好的研发文档），它自然会倾向于遵循现有的代码模式和约定，而无需你显式教导。

如果你对此非常执着，甚至可以考虑设置一个 Claude Code Stop 钩子（Hook），运行你的格式化程序和 Linter，并将错误展示给 Claude 让它修复。不要让 Claude 自己去肉眼查找格式问题。

**加分项**：使用可以自动修复问题的 Linter（我们推荐 Biome），并仔细调整规则，确保在安全的前提下实现最大的自动修复覆盖率。

你还可以创建一个斜杠命令（Slash Command），包含你的代码指南，并指向版本控制中的变更或 `git status` 等。这样，你可以将“实现功能”和“代码格式化”分开处理。结果你会发现，两者的效果都会更好。

### 5. 不要使用 /init 或自动生成 CLAUDE.md

Claude Code 和其他基于 OpenCode 的工具都提供了自动生成 `CLAUDE.md`（或 `AGENTS.md`）的方法。

因为 `CLAUDE.md` 会伴随 Claude Code 进入每一次会话，它是整个工具链中**最具决定性的环节（Highest Leverage Point）**——用得好是神助攻，用得不好就是猪队友。

一行糟糕的代码仅仅是一行糟糕的代码。但一个糟糕的实施计划可能会产生大量糟糕的代码。而如果一行关于系统工作原理的糟糕描述导致了误解，可能会导致计划中出现大量错误，最终导致成倍的糟糕代码。

`CLAUDE.md` 文件会影响你工作流的每一个阶段以及产出的每一个工件。因此，我们认为你应该花时间**仔细斟酌**写入其中的每一行内容。

## 结语

`CLAUDE.md` 的核心作用是引导 Claude 熟悉你的代码库。它应该定义项目的 **WHAT（是什么）**、**WHY（为什么）** 和 **HOW（怎么做）**。

记住，**少（指令）即是多**。虽然不该省略必要的指令，但在文件中应尽可能保持指令精简。

保持 `CLAUDE.md` 内容简洁且具有普遍适用性。使用**渐进式披露**技巧——不要一股脑告诉 Claude 所有信息，而是告诉它如何找到重要信息，让它仅在需要时去获取，从而避免上下文窗口膨胀或指令过多。

Claude 不是代码检查工具。请使用 Linter 和格式化工具，并在必要时使用 Hooks 和 Slash Commands 等功能。

`CLAUDE.md` 是 AI 辅助编程中最具杠杆效应的关键点，所以**避免自动生成它**。你需要精心打磨其内容，以获得最佳效果。
